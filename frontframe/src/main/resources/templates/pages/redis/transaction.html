<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<th:block th:fragment="link">
  <pre>
Redis事务的常用命令：
1.14.2.1	multi
	语法：multi
功能：用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。
返回值：开启成功返回OK

1.14.2.2	exec
语法：exec
功能：在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。
如果在把命令压入队列的过程中报错，则整个队列中的命令都不会执行，执行结果报错；
如果在压队列的过程中正常，在执行队列中某一个命令报错，则只会影响本条命令的执行结果，其它命令正常运行；
当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令;而一旦执行了exec命令，之前加的所有watch监控全部取消。
返回值：这个命令的返回值是一个数组，其中的每个元素分别是原子化事务中的每个命令的返回值。 当使用WATCH命令时，如果事务执行中止，那么EXEC命令就会返回一个Null值。

1.14.2.3	discard
语法：discard
功能：清除所有先前在一个事务中放入队列的命令，并且结束事务。
如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。
返回值：清除成功，返回OK。

1.14.2.4	watch
语法：watch key [key …]
功能：当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的。如果被监控的key值在本事务外有修改时，则本事务所有指令都不会被执行。Watch命令相当于关系型数据库中的乐观锁。
返回值：监控成功，返回OK。

1.14.2.5	unwatch
语法：unwatch
功能：清除所有先前为一个事务监控的键。
	  如果在watch命令之后你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。
返回值：清除成功，返回OK。

1.14.3	Redis事务小结：
1、单独的隔离操作：事务中的所有命令都会序列化、顺序地执行。事务在执行过程中，不会被其它客户端发来的命令请求所打断。
2、不保证事务的原子性：redis同一个事务中如果一条命令执行失败，其后的命令仍然可能会被执行，redis的事务没有回滚。Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。

  </pre>
</th:block>

</html>
